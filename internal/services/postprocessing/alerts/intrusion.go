package alerts

import (
	"fmt"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"
)

// HandleIntrusionDetection determines if an intrusion alert should be created
func HandleIntrusionDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	if detection.IsIntrusion == nil || !*detection.IsIntrusion {
		return decision
	}

	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypeIntrusionDetection
	decision.Severity = models.AlertSeverityHigh
	decision.Title = "Intrusion Detected"
	decision.Description = fmt.Sprintf("Intrusion detected with %.1f%% confidence", detection.Score*100)
	decision.Metadata["is_intrusion"] = true

	return decision
}

// BuildIntrusionAlert creates a complete intrusion alert payload with images
func BuildIntrusionAlert(detection models.Detection, cameraID string, frame []byte) models.AlertPayload {

	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeIntrusionDetection,
		Severity:     models.AlertSeverityHigh,
		Title:        "Intrusion Detected",
		Description:  fmt.Sprintf("Intrusion detected with %.1f%% confidence", detection.Score*100),
		CooldownType: "normal",
		Metadata:     map[string]interface{}{"is_intrusion": true},
	}

	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			ModelName:           detection.ModelName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Context + detection crop from annotated frame by default
	helpers.AddContextImage(&payload, frame, cameraID, detection.TrackID, "intrusion alert")
	helpers.AddDetectionImage(&payload, detection, frame, cameraID, fmt.Sprintf("intrusion_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":   decision.AlertType,
		"is_intrusion": true,
	})

	return payload
}

func BuildConsolidatedIntrusionAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrameData []byte) models.AlertPayload {
	if len(detections) == 0 {
		return models.AlertPayload{}
	}

	// Get the primary detection (highest confidence) for main alert info
	primaryDetection := findPrimaryIntrusionDetection(detections)
	totalDetections := len(detections)

	// Calculate average confidence
	totalScore := 0.0
	for _, det := range detections {
		totalScore += float64(det.Score)
	}
	avgScore := totalScore / float64(totalDetections)

	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeIntrusionDetection,
		Severity:     models.AlertSeverityHigh,
		Title:        createConsolidatedIntrusionTitle(totalDetections),
		Description:  createConsolidatedIntrusionDescription(detections, avgScore),
		CooldownType: "normal",
		Metadata: map[string]interface{}{
			"is_intrusion":       true,
			"total_detections":   totalDetections,
			"average_confidence": avgScore,
		},
	}

	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(primaryDetection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: float32(avgScore),
			DetectionType:       primaryDetection.ClassName,
			TrackerID:           primaryDetection.TrackID,
			ProjectName:         primaryDetection.ProjectName,
			ModelName:           primaryDetection.ModelName,
			AutoGenerated:       true,
			Timestamp:           primaryDetection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using annotated frame (shows full scene with overlays)
	helpers.AddContextImage(&payload, annotatedFrameData, cameraID, primaryDetection.TrackID, "Consolidated intrusion alert")

	// Add detection images for each intrusion detection
	for i, detection := range detections {
		helpers.AddDetectionImage(&payload, detection, rawFrame, cameraID,
			fmt.Sprintf("intrusion_consolidated_%d_%d", detection.TrackID, i),
			map[string]interface{}{
				"alert_type":       decision.AlertType,
				"is_intrusion":     true,
				"detection_index":  i,
				"total_detections": totalDetections,
			})
	}

	return payload
}

// Helper function to find the primary intrusion detection (highest confidence)
func findPrimaryIntrusionDetection(detections []models.Detection) models.Detection {
	if len(detections) == 1 {
		return detections[0]
	}

	highest := detections[0]
	for _, det := range detections[1:] {
		if det.Score > highest.Score {
			highest = det
		}
	}
	return highest
}

// Helper function to create consolidated intrusion title
func createConsolidatedIntrusionTitle(detectionCount int) string {
	if detectionCount == 1 {
		return "Intrusion Detected"
	}
	return fmt.Sprintf("Multiple Intrusions Detected (%d detections)", detectionCount)
}

// Helper function to create consolidated intrusion description
func createConsolidatedIntrusionDescription(detections []models.Detection, avgScore float64) string {
	totalDetections := len(detections)

	description := fmt.Sprintf("Multiple intrusion detections identified across %d objects:\n\n", totalDetections)
	description += fmt.Sprintf("Average confidence: %.1f%%\n\n", avgScore*100)

	description += "Detailed breakdown:\n"
	for i, det := range detections {
		confidence := det.Score * 100
		description += fmt.Sprintf("Detection %d (Track ID: %d): %.1f%% confidence\n",
			i+1, det.TrackID, confidence)
	}

	return description
}
