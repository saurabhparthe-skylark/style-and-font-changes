package alerts

import (
	"fmt"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"

	"github.com/rs/zerolog/log"
)

// HandlePersonDetection handles person detection alerts
func HandlePersonDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	// Check if this is a high-confidence person detection or has send_alert flag
	if detection.Score < 0.7 && !detection.SendAlert {
		return decision
	}

	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypePersonDetection
	decision.Severity = models.AlertSeverityMedium
	decision.Title = "Person Detection"
	decision.Description = fmt.Sprintf("Person detected with %.1f%% confidence", detection.Score*100)
	decision.CooldownType = "normal"
	decision.Metadata["detection_confidence"] = detection.Score
	decision.Metadata["send_alert_flag"] = detection.SendAlert

	// Check for intrusion flag
	if detection.IsIntrusion != nil && *detection.IsIntrusion {
		decision.AlertType = models.AlertTypeIntrusionDetection
		decision.Severity = models.AlertSeverityHigh
		decision.Title = "Intrusion Alert"
		decision.Description = fmt.Sprintf("Unauthorized person detected with %.1f%% confidence", detection.Score*100)
		decision.Metadata["intrusion_detected"] = true
	}

	return decision
}

// BuildPersonAlert creates a complete person alert payload with images
func BuildPersonAlert(detection models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {

	// Create alert decision
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypePersonDetection,
		Severity:     models.AlertSeverityMedium,
		Title:        "Person Detection",
		Description:  fmt.Sprintf("Person detected with %.1f%% confidence", detection.Score*100),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Check for intrusion
	if detection.IsIntrusion != nil && *detection.IsIntrusion {
		decision.AlertType = models.AlertTypeIntrusionDetection
		decision.Severity = models.AlertSeverityHigh
		decision.Title = "Intrusion Alert"
		decision.Description = fmt.Sprintf("Unauthorized person detected with %.1f%% confidence", detection.Score*100)
		decision.Metadata["intrusion_detected"] = true
	}

	// Add person-specific metadata
	decision.Metadata["detection_confidence"] = detection.Score
	decision.Metadata["send_alert_flag"] = detection.SendAlert
	decision.Metadata["detection_label"] = detection.Label

	// Build alert payload with images using helpers
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			ModelName:           detection.ModelName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using helper
	helpers.AddContextImage(&payload, annotatedFrame, cameraID, detection.TrackID, "person alert")

	// Add detection image using helper with person-specific metadata (using raw frame)
	helpers.AddDetectionImage(&payload, detection, rawFrame, cameraID, fmt.Sprintf("person_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":      decision.AlertType,
		"detection_label": detection.Label,
		"send_alert_flag": detection.SendAlert,
		"is_intrusion":    detection.IsIntrusion != nil && *detection.IsIntrusion,
	})

	return payload
}

// BuildConsolidatedPersonAlert creates a consolidated person alert for multiple detections
func BuildConsolidatedPersonAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	if len(detections) == 0 {
		log.Warn().Str("camera_id", cameraID).Msg("No detections provided for consolidated person alert")
		return models.AlertPayload{}
	}

	// Get the primary detection (highest confidence) for main alert info
	primaryDetection := findHighestConfidencePersonDetection(detections)
	totalDetections := len(detections)

	// Check if any detection has intrusion flag
	hasIntrusion := false
	for _, det := range detections {
		if det.IsIntrusion != nil && *det.IsIntrusion {
			hasIntrusion = true
			break
		}
	}

	// Create alert decision
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypePersonDetection,
		Severity:     models.AlertSeverityMedium,
		Title:        fmt.Sprintf("Person Detection (%d people)", totalDetections),
		Description:  fmt.Sprintf("%d people detected with high confidence", totalDetections),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Override for intrusion
	if hasIntrusion {
		decision.AlertType = models.AlertTypeIntrusionDetection
		decision.Severity = models.AlertSeverityHigh
		decision.Title = fmt.Sprintf("Intrusion Alert (%d people)", totalDetections)
		decision.Description = fmt.Sprintf("%d unauthorized people detected", totalDetections)
		decision.Metadata["intrusion_detected"] = true
	}

	// Add person-specific metadata
	decision.Metadata["detection_confidence"] = primaryDetection.Score
	decision.Metadata["send_alert_flag"] = primaryDetection.SendAlert
	decision.Metadata["detection_label"] = primaryDetection.Label
	decision.Metadata["total_detections"] = totalDetections
	decision.Metadata["has_intrusion"] = hasIntrusion

	// Build alert payload using primary detection for core info
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(primaryDetection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: primaryDetection.Score,
			DetectionType:       primaryDetection.ClassName,
			TrackerID:           primaryDetection.TrackID,
			ProjectName:         primaryDetection.ProjectName,
			ModelName:           primaryDetection.ModelName,
			AutoGenerated:       true,
			Timestamp:           primaryDetection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using annotated frame (shows full scene with overlays)
	helpers.AddContextImage(&payload, annotatedFrame, cameraID, primaryDetection.TrackID, "Consolidated person alert")

	// Add detection images: primary from annotated (with overlays), others from raw (clean)
	for i, detection := range detections {
		frameForCrop := rawFrame
		if detection.TrackID == primaryDetection.TrackID {
			frameForCrop = rawFrame // Use raw frame for ALL detection crops
		}
		helpers.AddDetectionImage(&payload, detection, frameForCrop, cameraID,
			fmt.Sprintf("person_consolidated_%d_%d", detection.TrackID, i),
			map[string]interface{}{
				"alert_type":       decision.AlertType,
				"detection_label":  detection.Label,
				"send_alert_flag":  detection.SendAlert,
				"detection_index":  i,
				"total_detections": totalDetections,
				"is_intrusion":     detection.IsIntrusion != nil && *detection.IsIntrusion,
			})
	}

	return payload
}

// Helper function to find highest confidence person detection
func findHighestConfidencePersonDetection(detections []models.Detection) models.Detection {
	if len(detections) == 1 {
		return detections[0]
	}

	highest := detections[0]
	for _, det := range detections[1:] {
		if det.Score > highest.Score {
			highest = det
		}
	}
	return highest
}
