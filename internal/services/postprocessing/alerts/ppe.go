package alerts

import (
	"fmt"
	"strings"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"

	"github.com/rs/zerolog/log"
)

// HandlePPEDetection handles PPE detection alerts
func HandlePPEDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	// Build violations from available fields if missing
	violations := append([]string{}, detection.Violations...)

	//if send alert is not true, return decision
	if !decision.ShouldAlert {
		return decision
	}

	// Derive violations from has_* flags when present
	if detection.HasVest != nil && !*detection.HasVest {
		violations = append(violations, "vest violation")
	}
	if detection.HasHelmet != nil && !*detection.HasHelmet {
		violations = append(violations, "helmet violation")
	}
	if detection.HasGloves != nil && !*detection.HasGloves {
		violations = append(violations, "gloves violation")
	}
	if detection.HasGlasses != nil && !*detection.HasGlasses {
		violations = append(violations, "glasses violation")
	}

	// Include any ppe_items passed from AI directly
	if len(detection.PPEItems) > 0 {
		for _, item := range detection.PPEItems {
			lower := strings.ToLower(item)
			if strings.Contains(lower, "no_") || strings.Contains(lower, "missing") || strings.Contains(lower, "violation") {
				violations = append(violations, item)
			}
		}
	}

	// Compliance flag: treat non-compliant as violation trigger
	if detection.Compliance != nil {
		comp := strings.ToLower(strings.TrimSpace(*detection.Compliance))
		if comp == "non_compliant" || comp == "noncompliant" || strings.Contains(comp, "violation") {
			if len(violations) == 0 {
				violations = append(violations, "ppe non-compliance")
			}
		}
	}

	if len(violations) == 0 {
		return decision
	}

	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypePPEViolation
	decision.Severity = models.AlertSeverityHigh
	decision.Title = CreatePPETitle(violations)
	// Overwrite detection.Violations in description build context without mutating input
	temp := detection
	temp.Violations = violations
	decision.Description = CreatePPEDescription(temp)
	decision.Metadata["ppe_violations"] = violations
	decision.Metadata["ppe_compliance"] = detection.Compliance
	decision.Metadata["violation_count"] = len(violations)

	log.Info().
		Int32("track_id", detection.TrackID).
		Int("violation_count", len(violations)).
		Strs("violations", violations).
		Msg("PPE violation alert will be created (derived)")

	return decision
}

// BuildPPEAlert creates a complete PPE alert payload with images
func BuildPPEAlert(detection models.Detection, cameraID string, frame []byte) models.AlertPayload {
	log.Info().
		Str("camera_id", cameraID).
		Int32("track_id", detection.TrackID).
		Int("violation_count", len(detection.Violations)).
		Msg("üèóÔ∏è Building PPE alert with images")

	// Create alert decision first
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypePPEViolation,
		Severity:     models.AlertSeverityHigh,
		Title:        CreatePPETitle(detection.Violations),
		Description:  CreatePPEDescription(detection),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Add PPE-specific metadata
	decision.Metadata["ppe_violations"] = detection.Violations
	decision.Metadata["ppe_compliance"] = detection.Compliance
	decision.Metadata["violation_count"] = len(detection.Violations)

	// Build alert payload with images using helpers
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
			PPEViolations:       detection.Violations,
			PPECompliance:       detection.Compliance,
			ViolationCount:      len(detection.Violations),
			ViolationTypes:      detection.Violations,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using helper
	helpers.AddContextImage(&payload, frame, cameraID, detection.TrackID, "PPE alert")

	// Add detection image using helper with PPE-specific metadata
	helpers.AddDetectionImage(&payload, detection, frame, cameraID, fmt.Sprintf("ppe_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type": decision.AlertType,
		"violations": detection.Violations,
	})

	return payload
}

// BuildConsolidatedPPEAlert creates a consolidated PPE alert for multiple detections in the same frame
func BuildConsolidatedPPEAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	if len(detections) == 0 {
		log.Warn().Str("camera_id", cameraID).Msg("No detections provided for consolidated PPE alert")
		return models.AlertPayload{}
	}

	// Get the primary detection (highest confidence) for main alert info
	primaryDetection := findPrimaryPPEDetection(detections)

	// Collect all violations from all detections
	allViolations := make([]string, 0)
	violationCounts := make(map[string]int)
	totalDetections := len(detections)

	for _, det := range detections {
		for _, violation := range det.Violations {
			violationCounts[violation]++
		}
		allViolations = append(allViolations, det.Violations...)
	}

	// Remove duplicates from violations list for title/description
	uniqueViolations := removeDuplicateStrings(allViolations)

	log.Info().
		Str("camera_id", cameraID).
		Int("total_detections", totalDetections).
		Int("unique_violations", len(uniqueViolations)).
		Msg("üèóÔ∏è Building consolidated PPE alert with multiple detections")

	// Create alert decision with consolidated information
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypePPEViolation,
		Severity:     models.AlertSeverityHigh,
		Title:        CreateConsolidatedPPETitle(uniqueViolations, totalDetections),
		Description:  CreateConsolidatedPPEDescription(detections, violationCounts),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Add consolidated PPE-specific metadata
	decision.Metadata["ppe_violations"] = uniqueViolations
	decision.Metadata["violation_counts"] = violationCounts
	decision.Metadata["total_detections"] = totalDetections

	// Build alert payload using primary detection for core info
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(primaryDetection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: primaryDetection.Score,
			DetectionType:       primaryDetection.ClassName,
			TrackerID:           primaryDetection.TrackID,
			ProjectName:         primaryDetection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           primaryDetection.Timestamp,
			PPEViolations:       uniqueViolations,
			PPECompliance:       primaryDetection.Compliance,
			ViolationCount:      len(uniqueViolations),
			ViolationTypes:      uniqueViolations,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using annotated frame (shows full scene with overlays)
	helpers.AddContextImage(&payload, annotatedFrame, cameraID, primaryDetection.TrackID, "Consolidated PPE alert")

	// Add detection images: primary from annotated (with overlays), others from raw (clean)
	for i, detection := range detections {
		frameForCrop := rawFrame
		if detection.TrackID == primaryDetection.TrackID {
			frameForCrop = rawFrame
		}
		helpers.AddDetectionImage(&payload, detection, frameForCrop, cameraID,
			fmt.Sprintf("ppe_consolidated_%d_%d", detection.TrackID, i),
			map[string]interface{}{
				"alert_type":       decision.AlertType,
				"violations":       detection.Violations,
				"detection_index":  i,
				"total_detections": totalDetections,
			})
	}

	return payload
}

// Helper functions for consolidated alerts
func findPrimaryPPEDetection(detections []models.Detection) models.Detection {
	if len(detections) == 1 {
		return detections[0]
	}

	highest := detections[0]
	for _, det := range detections[1:] {
		if det.Score > highest.Score {
			highest = det
		}
	}
	return highest
}

func removeDuplicateStrings(slice []string) []string {
	keys := make(map[string]bool)
	unique := []string{}

	for _, item := range slice {
		if !keys[item] {
			keys[item] = true
			unique = append(unique, item)
		}
	}
	return unique
}

// CreatePPETitle generates appropriate title for PPE violations
func CreatePPETitle(violations []string) string {
	if len(violations) == 1 {
		return fmt.Sprintf("PPE Violation: %s", strings.Title(strings.ReplaceAll(violations[0], " violation", "")))
	}
	return fmt.Sprintf("Multiple PPE Violations (%d items)", len(violations))
}

// CreateConsolidatedPPETitle generates title for consolidated PPE alerts with multiple detections
func CreateConsolidatedPPETitle(violations []string, detectionCount int) string {
	if detectionCount == 1 {
		return CreatePPETitle(violations)
	}

	if len(violations) == 1 {
		return fmt.Sprintf("PPE Violation: %s (%d people detected)",
			strings.Title(strings.ReplaceAll(violations[0], " violation", "")), detectionCount)
	}
	return fmt.Sprintf("Multiple PPE Violations: %d types across %d people", len(violations), detectionCount)
}

// CreateConsolidatedPPEDescription generates detailed description for consolidated PPE alerts
func CreateConsolidatedPPEDescription(detections []models.Detection, violationCounts map[string]int) string {
	totalDetections := len(detections)

	var description strings.Builder
	description.WriteString(fmt.Sprintf("PPE safety violations detected across %d people:\n\n", totalDetections))

	// Summarize violation types and counts
	for violation, count := range violationCounts {
		switch {
		case strings.Contains(strings.ToLower(violation), "vest"):
			description.WriteString(fmt.Sprintf("‚ùå Missing Safety Vest: %d people\n", count))
		case strings.Contains(strings.ToLower(violation), "helmet"):
			description.WriteString(fmt.Sprintf("‚ùå Missing Safety Helmet: %d people\n", count))
		case strings.Contains(strings.ToLower(violation), "glasses"):
			description.WriteString(fmt.Sprintf("‚ùå Missing Safety Glasses: %d people\n", count))
		case strings.Contains(strings.ToLower(violation), "gloves"):
			description.WriteString(fmt.Sprintf("‚ùå Missing Safety Gloves: %d people\n", count))
		default:
			description.WriteString(fmt.Sprintf("‚ùå %s: %d people\n", strings.Title(violation), count))
		}
	}

	// Add individual detection details
	description.WriteString("\nDetailed breakdown:\n")
	for i, det := range detections {
		if len(det.Violations) > 0 {
			confidence := det.Score * 100
			description.WriteString(fmt.Sprintf("Person %d (%.1f%% confidence): %s\n",
				i+1, confidence, strings.Join(det.Violations, ", ")))
		}
	}

	return description.String()
}

// CreatePPEDescription generates detailed description for PPE violations
func CreatePPEDescription(detection models.Detection) string {
	violationDetails := make([]string, 0, len(detection.Violations))
	for _, violation := range detection.Violations {
		switch {
		case strings.Contains(strings.ToLower(violation), "vest"):
			violationDetails = append(violationDetails, "‚ùå Missing Safety Vest")
		case strings.Contains(strings.ToLower(violation), "helmet"):
			violationDetails = append(violationDetails, "‚ùå Missing Safety Helmet")
		case strings.Contains(strings.ToLower(violation), "glasses"):
			violationDetails = append(violationDetails, "‚ùå Missing Safety Glasses")
		case strings.Contains(strings.ToLower(violation), "gloves"):
			violationDetails = append(violationDetails, "‚ùå Missing Safety Gloves")
		default:
			violationDetails = append(violationDetails, fmt.Sprintf("‚ùå %s", strings.Title(violation)))
		}
	}

	description := fmt.Sprintf("PPE safety violations detected:\n%s", strings.Join(violationDetails, "\n"))
	description += fmt.Sprintf("\n\nDetection confidence: %.1f%%", detection.Score*100)

	if detection.Compliance != nil {
		description += fmt.Sprintf("\nCompliance status: %s", strings.Title(*detection.Compliance))
	}

	return description
}
