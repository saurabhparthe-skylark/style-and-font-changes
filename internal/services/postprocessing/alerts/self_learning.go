package alerts

import (
	"fmt"
	"strings"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"

	"github.com/rs/zerolog/log"
)

// HandleSelfLearningDetection handles self-learning detection alerts
func HandleSelfLearningDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	// Self-learning detections indicate new patterns learned by the model
	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypeSelfLearned
	decision.Severity = models.AlertSeverityMedium
	decision.Title = CreateSelfLearningTitle(detection.Label)
	decision.Description = CreateSelfLearningDescription(detection)
	decision.CooldownType = "self_learning"

	// Add self-learning specific metadata
	decision.Metadata["self_learned_label"] = detection.Label
	decision.Metadata["learning_confidence"] = detection.Score
	decision.Metadata["detection_method"] = "self_learning"
	decision.Metadata["is_rpn_detection"] = detection.IsRPN

	log.Info().
		Int32("track_id", detection.TrackID).
		Str("learned_pattern", detection.Label).
		Float32("confidence", detection.Score).
		Bool("is_rpn", detection.IsRPN).
		Msg("Self-learning detection alert will be created")

	return decision
}

// BuildSelfLearningAlert creates a complete self-learning alert payload with images
func BuildSelfLearningAlert(detection models.Detection, cameraID string, frame []byte) models.AlertPayload {
	log.Info().
		Str("camera_id", cameraID).
		Int32("track_id", detection.TrackID).
		Str("learned_pattern", detection.Label).
		Float32("confidence", detection.Score).
		Bool("is_rpn", detection.IsRPN).
		Msg("üèóÔ∏è Building self-learning alert with images")

	// Create alert decision
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeSelfLearned,
		Severity:     models.AlertSeverityMedium,
		Title:        CreateSelfLearningTitle(detection.Label),
		Description:  CreateSelfLearningDescription(detection),
		CooldownType: "self_learning",
		Metadata:     make(map[string]interface{}),
	}

	// Add self-learning specific metadata
	decision.Metadata["self_learned_label"] = detection.Label
	decision.Metadata["learning_confidence"] = detection.Score
	decision.Metadata["detection_method"] = "self_learning"
	decision.Metadata["is_rpn_detection"] = detection.IsRPN
	decision.Metadata["model_adaptation"] = true

	// Build alert payload with images using helpers
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
			SelfLearnedLabel:    &detection.Label,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using helper
	helpers.AddContextImage(&payload, frame, cameraID, detection.TrackID, "self-learning alert")

	// Add detection image using helper with self-learning specific metadata
	helpers.AddDetectionImage(&payload, detection, frame, cameraID, fmt.Sprintf("self_learning_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":         decision.AlertType,
		"self_learned_label": detection.Label,
		"detection_method":   "self_learning",
		"is_rpn_detection":   detection.IsRPN,
		"model_adaptation":   true,
	})

	return payload
}

// BuildConsolidatedSelfLearningAlert creates a consolidated self-learning alert for multiple detections
func BuildConsolidatedSelfLearningAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	// For now, delegate to general consolidated alert builder
	// TODO: Implement self-learning-specific consolidated logic
	return BuildConsolidatedGeneralAlert(detections, cameraID, rawFrame, annotatedFrame)
}

// CreateSelfLearningTitle generates appropriate title for self-learning detections
func CreateSelfLearningTitle(label string) string {
	// Clean up the label for display
	cleanLabel := strings.Title(strings.TrimSpace(label))

	if cleanLabel == "" {
		return "New Pattern Learned"
	}

	return fmt.Sprintf("Self-Learned Detection: %s", cleanLabel)
}

// CreateSelfLearningDescription generates detailed description for self-learning detections
func CreateSelfLearningDescription(detection models.Detection) string {
	description := fmt.Sprintf("Self-learning model detected %s with %.1f%% confidence",
		detection.Label, detection.Score*100)

	description += "\n\nThis detection represents a new pattern that the AI model has learned to identify."

	if detection.IsRPN {
		description += "\nDetection method: Region Proposal Network (RPN)"
	}

	// Add context based on confidence level
	if detection.Score >= 0.8 {
		description += "\n\n‚úÖ High confidence - pattern is well established"
	} else if detection.Score >= 0.6 {
		description += "\n\n‚ö†Ô∏è Medium confidence - pattern is being learned"
	} else {
		description += "\n\nüîç Lower confidence - early stage pattern detection"
	}

	if detection.ProjectName != "" {
		description += fmt.Sprintf("\nProject context: %s", detection.ProjectName)
	}

	description += "\n\nThis alert helps track model adaptation and new pattern discovery."

	return description
}
