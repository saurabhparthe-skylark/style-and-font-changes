package alerts

import (
	"fmt"
	"strings"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"

	"github.com/rs/zerolog/log"
)

// HandleVehicleDetection handles vehicle detection alerts
func HandleVehicleDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypeVehicleDetection
	decision.Severity = models.AlertSeverityMedium
	decision.Title = createVehicleTitle(detection.Label)
	decision.Description = fmt.Sprintf("%s detected with %.1f%% confidence", detection.Label, detection.Score*100)
	decision.Metadata["vehicle_label"] = detection.Label
	return decision
}

// BuildVehicleAlert creates a complete vehicle alert payload with images
func BuildVehicleAlert(detection models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	log.Info().
		Str("camera_id", cameraID).
		Int32("track_id", detection.TrackID).
		Str("vehicle_type", detection.Label).
		Msg("üèóÔ∏è Building vehicle alert with images")

	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeVehicleDetection,
		Severity:     models.AlertSeverityMedium,
		Title:        createVehicleTitle(detection.Label),
		Description:  fmt.Sprintf("%s detected with %.1f%% confidence", detection.Label, detection.Score*100),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	decision.Metadata["vehicle_label"] = detection.Label
	decision.Metadata["object_type"] = "vehicle"

	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	helpers.AddContextImage(&payload, annotatedFrame, cameraID, detection.TrackID, "vehicle alert")
	helpers.AddDetectionImage(&payload, detection, rawFrame, cameraID, fmt.Sprintf("vehicle_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":    decision.AlertType,
		"vehicle_label": strings.ToLower(detection.Label),
	})

	return payload
}

// BuildConsolidatedVehicleAlert creates a consolidated vehicle alert for multiple detections
func BuildConsolidatedVehicleAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	if len(detections) == 0 {
		log.Warn().Str("camera_id", cameraID).Msg("No detections provided for consolidated vehicle alert")
		return models.AlertPayload{}
	}

	// Select primary detection (highest confidence)
	primaryDetection := findHighestConfidenceDetection(detections)

	// Aggregate labels
	labelCounts := make(map[string]int)
	for _, det := range detections {
		label := strings.ToLower(det.Label)
		labelCounts[label]++
	}

	uniqueLabels := make([]string, 0, len(labelCounts))
	for l := range labelCounts {
		uniqueLabels = append(uniqueLabels, l)
	}

	log.Info().
		Str("camera_id", cameraID).
		Int("total_detections", len(detections)).
		Int("unique_vehicle_types", len(uniqueLabels)).
		Msg("üèóÔ∏è Building consolidated vehicle alert with multiple detections")

	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeVehicleDetection,
		Severity:     models.AlertSeverityMedium,
		Title:        createConsolidatedVehicleTitle(uniqueLabels, len(detections), primaryDetection.Label),
		Description:  createConsolidatedVehicleDescription(labelCounts, detections),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	decision.Metadata["object_type"] = "vehicle"
	decision.Metadata["vehicle_labels"] = uniqueLabels
	decision.Metadata["label_counts"] = labelCounts
	decision.Metadata["total_detections"] = len(detections)

	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(primaryDetection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: primaryDetection.Score,
			DetectionType:       "vehicle_detection_lr",
			TrackerID:           primaryDetection.TrackID,
			ProjectName:         primaryDetection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           primaryDetection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Use annotated for context; RAW for all detection crops (no overlays in crops)
	helpers.AddContextImage(&payload, annotatedFrame, cameraID, primaryDetection.TrackID, "Consolidated vehicle alert")
	for i, det := range detections {
		helpers.AddDetectionImage(&payload, det, rawFrame, cameraID,
			fmt.Sprintf("vehicle_consolidated_%d_%d", det.TrackID, i),
			map[string]interface{}{
				"alert_type":       decision.AlertType,
				"vehicle_label":    strings.ToLower(det.Label),
				"detection_index":  i,
				"total_detections": len(detections),
			})
	}

	return payload
}

func createVehicleTitle(label string) string {
	l := strings.ToLower(label)
	switch {
	case strings.Contains(l, "car"):
		return "Car Detected"
	case strings.Contains(l, "truck"):
		return "Truck Detected"
	case strings.Contains(l, "bus"):
		return "Bus Detected"
	case strings.Contains(l, "motorcycle") || strings.Contains(l, "bike"):
		return "Motorbike Detected"
	case strings.Contains(l, "van"):
		return "Van Detected"
	default:
		return "Vehicle Detected"
	}
}

func createConsolidatedVehicleTitle(uniqueLabels []string, count int, primaryLabel string) string {
	if count == 1 {
		return createVehicleTitle(primaryLabel)
	}
	if len(uniqueLabels) == 1 {
		return fmt.Sprintf("%s (%d objects)", createVehicleTitle(uniqueLabels[0]), count)
	}
	return fmt.Sprintf("Multiple Vehicles Detected (%d objects)", count)
}

func createConsolidatedVehicleDescription(labelCounts map[string]int, detections []models.Detection) string {
	var b strings.Builder
	b.WriteString("Multiple vehicle detections in the scene:\n\n")
	for label, c := range labelCounts {
		b.WriteString(fmt.Sprintf("- %s: %d\n", strings.Title(label), c))
	}

	b.WriteString("\nDetailed breakdown:\n")
	for i, det := range detections {
		b.WriteString(fmt.Sprintf("Object %d (%.1f%%): %s\n", i+1, det.Score*100, strings.Title(det.Label)))
	}
	return b.String()
}
