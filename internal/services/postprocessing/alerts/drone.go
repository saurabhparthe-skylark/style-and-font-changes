package alerts

import (
	"fmt"
	"strings"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"

	"github.com/rs/zerolog/log"
)

// HandleDroneDetection handles drone/aircraft detection alerts
func HandleDroneDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	decision.ShouldAlert = true
	decision.AlertType = models.AlertTypeDroneDetection
	decision.Severity = models.AlertSeverityHigh
	decision.Title = CreateDroneTitle(detection.Label)
	decision.Description = fmt.Sprintf("%s detected with %.1f%% confidence", detection.Label, detection.Score*100)
	decision.Metadata["detection_subtype"] = detection.Label

	return decision
}

// BuildDroneAlert creates a complete drone alert payload with images
func BuildDroneAlert(detection models.Detection, cameraID string, frame []byte) models.AlertPayload {
	log.Info().
		Str("camera_id", cameraID).
		Int32("track_id", detection.TrackID).
		Str("drone_type", detection.Label).
		Msg("üèóÔ∏è Building drone alert with images")

	// Create alert decision
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeDroneDetection,
		Severity:     models.AlertSeverityHigh,
		Title:        CreateDroneTitle(detection.Label),
		Description:  fmt.Sprintf("%s detected with %.1f%% confidence", detection.Label, detection.Score*100),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Add drone-specific metadata
	decision.Metadata["detection_subtype"] = detection.Label
	decision.Metadata["aerial_object_type"] = strings.ToLower(detection.Label)

	// Build alert payload with images using helpers
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using helper
	helpers.AddContextImage(&payload, frame, cameraID, detection.TrackID, "drone alert")

	// Add detection image using helper with drone-specific metadata
	helpers.AddDetectionImage(&payload, detection, frame, cameraID, fmt.Sprintf("drone_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":         decision.AlertType,
		"detection_subtype":  detection.Label,
		"aerial_object_type": strings.ToLower(detection.Label),
	})

	return payload
}

// CreateDroneTitle generates appropriate title for drone detections
func CreateDroneTitle(label string) string {
	labelLower := strings.ToLower(label)
	switch {
	case strings.Contains(labelLower, "quadcopter"):
		return "Quadcopter Drone Detected"
	case strings.Contains(labelLower, "aircraft"):
		return "Aircraft Detected"
	case strings.Contains(labelLower, "payload"):
		return "Drone Payload Detected"
	case strings.Contains(labelLower, "bird"):
		return "Bird Detected"
	default:
		return "Aerial Object Detected"
	}
}
