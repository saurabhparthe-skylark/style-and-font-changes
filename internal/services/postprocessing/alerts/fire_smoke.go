package alerts

import (
	"fmt"
	"strings"

	"kepler-worker-go/internal/helpers"
	"kepler-worker-go/internal/models"
)

// HandleFireSmokeDetection handles fire and smoke detection alerts
func HandleFireSmokeDetection(detection models.Detection, decision models.AlertDecision) models.AlertDecision {
	if detection.SendAlert {
		decision.ShouldAlert = true
	}

	isFire := detection.IsFire != nil && *detection.IsFire
	isSmoke := detection.IsSmoke != nil && *detection.IsSmoke

	decision.AlertType = models.AlertTypeFireSmoke
	decision.Severity = models.AlertSeverityCritical
	decision.Title = CreateFireSmokeTitle(isFire, isSmoke)
	decision.Description = CreateFireSmokeDescription(detection, isFire, isSmoke)
	decision.Metadata["is_fire"] = isFire
	decision.Metadata["is_smoke"] = isSmoke

	if detection.FireIntensity != nil {
		decision.Metadata["fire_intensity"] = *detection.FireIntensity
	}
	if detection.SmokeDensity != nil {
		decision.Metadata["smoke_density"] = *detection.SmokeDensity
	}

	return decision
}

// BuildFireSmokeAlert creates a complete fire/smoke alert payload with images
func BuildFireSmokeAlert(detection models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	isFire := detection.IsFire != nil && *detection.IsFire
	isSmoke := detection.IsSmoke != nil && *detection.IsSmoke

	// Create alert decision
	decision := models.AlertDecision{
		ShouldAlert:  true,
		AlertType:    models.AlertTypeFireSmoke,
		Severity:     models.AlertSeverityCritical,
		Title:        CreateFireSmokeTitle(isFire, isSmoke),
		Description:  CreateFireSmokeDescription(detection, isFire, isSmoke),
		CooldownType: "normal",
		Metadata:     make(map[string]interface{}),
	}

	// Add fire/smoke-specific metadata
	decision.Metadata["is_fire"] = isFire
	decision.Metadata["is_smoke"] = isSmoke

	if detection.FireIntensity != nil {
		decision.Metadata["fire_intensity"] = *detection.FireIntensity
	}
	if detection.SmokeDensity != nil {
		decision.Metadata["smoke_density"] = *detection.SmokeDensity
	}

	// Build alert payload with images using helpers
	payload := models.AlertPayload{
		CameraID:        cameraID,
		DetectionRecord: helpers.CreateDetectionRecord(detection),
		Alert: models.Alert{
			AlertType:           decision.AlertType,
			Severity:            decision.Severity,
			Title:               decision.Title,
			Description:         decision.Description,
			DetectionConfidence: detection.Score,
			DetectionType:       detection.ClassName,
			TrackerID:           detection.TrackID,
			ProjectName:         detection.ProjectName,
			ModelName:           detection.ModelName,
			AutoGenerated:       true,
			Timestamp:           detection.Timestamp,
			IsFire:              detection.IsFire,
			IsSmoke:             detection.IsSmoke,
			FireIntensity:       detection.FireIntensity,
			SmokeDensity:        detection.SmokeDensity,
		},
		Metadata: decision.Metadata,
	}

	// Add context image using helper
	helpers.AddContextImage(&payload, annotatedFrame, cameraID, detection.TrackID, "fire/smoke alert")

	// Add detection image using helper with fire/smoke specific metadata
	helpers.AddDetectionImage(&payload, detection, rawFrame, cameraID, fmt.Sprintf("fire_smoke_alert_%d", detection.TrackID), map[string]interface{}{
		"alert_type":     decision.AlertType,
		"is_fire":        detection.IsFire,
		"is_smoke":       detection.IsSmoke,
		"fire_intensity": detection.FireIntensity,
		"smoke_density":  detection.SmokeDensity,
	})

	return payload
}

// BuildConsolidatedFireSmokeAlert creates a consolidated fire/smoke alert for multiple detections
func BuildConsolidatedFireSmokeAlert(detections []models.Detection, cameraID string, rawFrame []byte, annotatedFrame []byte) models.AlertPayload {
	// For now, delegate to general consolidated alert builder
	// TODO: Implement fire/smoke-specific consolidated logic
	return BuildConsolidatedGeneralAlert(detections, cameraID, rawFrame, annotatedFrame)
}

// CreateFireSmokeTitle generates appropriate title for fire/smoke detections
func CreateFireSmokeTitle(isFire, isSmoke bool) string {
	if isFire && isSmoke {
		return "Fire and Smoke Detected"
	} else if isFire {
		return "Fire Detected"
	} else {
		return "Smoke Detected"
	}
}

// CreateFireSmokeDescription generates detailed description for fire/smoke detections
func CreateFireSmokeDescription(detection models.Detection, isFire, isSmoke bool) string {
	var elements []string
	if isFire {
		elements = append(elements, "fire")
	}
	if isSmoke {
		elements = append(elements, "smoke")
	}

	description := fmt.Sprintf("Critical safety alert: %s detected with %.1f%% confidence",
		strings.Join(elements, " and "), detection.Score*100)

	if detection.FireIntensity != nil && *detection.FireIntensity > 0 {
		description += fmt.Sprintf("\nFire intensity: %.2f", *detection.FireIntensity)
	}
	if detection.SmokeDensity != nil && *detection.SmokeDensity > 0 {
		description += fmt.Sprintf("\nSmoke density: %.2f", *detection.SmokeDensity)
	}

	return description
}
